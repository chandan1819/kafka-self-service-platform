# Default values for kafka-ops-agent
# This is a YAML-formatted file.

# Global configuration
global:
  imageRegistry: ""
  imagePullSecrets: []
  storageClass: ""

# Image configuration
image:
  registry: docker.io
  repository: kafka-ops-agent
  tag: "1.0.0"
  pullPolicy: IfNotPresent
  pullSecrets: []

# Deployment configuration
replicaCount: 3

# Service configuration
service:
  type: ClusterIP
  api:
    port: 8000
    targetPort: api
  monitoring:
    port: 8080
    targetPort: monitoring
  annotations: {}
  labels: {}

# Ingress configuration
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: kafka-ops.example.com
      paths:
        - path: /
          pathType: Prefix
          service: api
        - path: /health
          pathType: Prefix
          service: monitoring
        - path: /metrics
          pathType: Prefix
          service: monitoring
  tls:
    - secretName: kafka-ops-tls
      hosts:
        - kafka-ops.example.com

# Resource configuration
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

# Autoscaling configuration
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  customMetrics:
    - name: kafka_ops_requests_per_second
      targetAverageValue: "100"

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Security Context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

# Pod Security Context
podSecurityContext:
  fsGroup: 1000

# Node selection
nodeSelector: {}
tolerations: []
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - kafka-ops-agent
          topologyKey: kubernetes.io/hostname

# Service Account
serviceAccount:
  create: true
  annotations: {}
  name: ""

# RBAC
rbac:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["namespaces", "pods", "services", "configmaps", "secrets", "persistentvolumeclaims"]
      verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
    - apiGroups: ["apps"]
      resources: ["deployments", "statefulsets", "replicasets"]
      verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

# Configuration
config:
  api:
    host: "0.0.0.0"
    port: 8000
    workers: 4
    timeout: 300
  
  monitoring:
    host: "0.0.0.0"
    port: 8080
    enabled: true
  
  logging:
    level: "INFO"
    format: "json"
  
  providers:
    docker:
      enabled: true
    kubernetes:
      enabled: true
      inCluster: true
    terraform:
      enabled: true
  
  features:
    auditLogging: true
    metricsCollection: true
    healthChecks: true
    cleanupScheduler: true
  
  security:
    apiKeyRequired: true
    rateLimiting: true
    corsEnabled: true
  
  cleanup:
    defaultRetentionDays: 7
    orphanedResourceCheckInterval: 3600
  
  alerts:
    enabled: true
    webhookUrl: ""

# Secrets
secrets:
  databasePassword: "kafka_ops_password"
  apiKey: "admin-secret-key"
  jwtSecret: "jwt-secret-key-for-jwt"

# External services configuration
externalServices:
  kafka:
    bootstrapServers: "kafka:9092"
    securityProtocol: "PLAINTEXT"
  
  database:
    host: "postgres"
    port: 5432
    name: "kafka_ops"
    username: "kafka_ops"
    # Password from secrets

# PostgreSQL dependency
postgresql:
  enabled: true
  auth:
    postgresPassword: "postgres_password"
    username: "kafka_ops"
    password: "kafka_ops_password"
    database: "kafka_ops"
  primary:
    persistence:
      enabled: true
      size: 8Gi
    resources:
      requests:
        memory: 256Mi
        cpu: 250m
      limits:
        memory: 512Mi
        cpu: 500m

# Redis dependency
redis:
  enabled: false
  auth:
    enabled: true
    password: "redis_password"
  master:
    persistence:
      enabled: true
      size: 8Gi

# Monitoring and observability
monitoring:
  serviceMonitor:
    enabled: true
    namespace: monitoring
    interval: 30s
    scrapeTimeout: 10s
    labels: {}
    annotations: {}
  
  prometheusRule:
    enabled: true
    namespace: monitoring
    labels: {}
    annotations: {}
    rules:
      - alert: KafkaOpsAgentDown
        expr: up{job="kafka-ops-agent"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Kafka Ops Agent is down"
          description: "Kafka Ops Agent has been down for more than 5 minutes"
      
      - alert: KafkaOpsAgentHighErrorRate
        expr: rate(kafka_ops_errors_total[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High error rate in Kafka Ops Agent"
          description: "Error rate is {{ $value }} errors per second"

# Network Policy
networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 8000
        - protocol: TCP
          port: 8080
  egress:
    - to: []
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
    - to:
        - namespaceSelector:
            matchLabels:
              name: kafka
      ports:
        - protocol: TCP
          port: 9092

# Persistence
persistence:
  enabled: true
  storageClass: ""
  accessMode: ReadWriteOnce
  size: 8Gi
  annotations: {}

# Init containers
initContainers:
  - name: wait-for-db
    image: postgres:15-alpine
    command:
      - sh
      - -c
      - |
        until pg_isready -h {{ .Values.externalServices.database.host }} -p {{ .Values.externalServices.database.port }} -U {{ .Values.externalServices.database.username }}; do
          echo "Waiting for database..."
          sleep 2
        done
        echo "Database is ready!"

# Additional containers
sidecars: []

# Additional volumes
extraVolumes: []

# Additional volume mounts
extraVolumeMounts: []

# Environment variables
extraEnvVars: []

# Environment variables from ConfigMaps
extraEnvVarsCM: []

# Environment variables from Secrets
extraEnvVarsSecret: []

# Pod annotations
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics/prometheus"

# Pod labels
podLabels: {}

# Deployment annotations
deploymentAnnotations: {}

# Deployment labels
deploymentLabels: {}

# Service annotations
serviceAnnotations: {}

# Service labels
serviceLabels: {}

# Lifecycle hooks
lifecycle: {}

# Health checks
livenessProbe:
  httpGet:
    path: /health/live
    port: monitoring
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health/ready
    port: monitoring
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

startupProbe:
  httpGet:
    path: /health/live
    port: monitoring
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 12

# Custom startup command
command: []
args: []

# Priority class
priorityClassName: ""

# Runtime class
runtimeClassName: ""

# DNS policy
dnsPolicy: ClusterFirst

# DNS config
dnsConfig: {}

# Host aliases
hostAliases: []

# Termination grace period
terminationGracePeriodSeconds: 30